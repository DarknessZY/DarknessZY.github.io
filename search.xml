<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TS基础</title>
    <url>/2022/09/22/Typescript/</url>
    <content><![CDATA[<h3 id="一、基础类型"><a href="#一、基础类型" class="headerlink" title="一、基础类型"></a>一、基础类型</h3><p>1.布尔类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let bool: boolean;</span><br><span class="line">bool = false;</span><br><span class="line">bool = 123; // Error：不能将类型“number”分配给类型“boolean”。</span><br></pre></td></tr></table></figure>

<p>2.数值类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num：number = 123</span><br></pre></td></tr></table></figure>

<p>3.字符串类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: string;</span><br><span class="line">str = &#x27;bac&#x27;;</span><br><span class="line">str = `数值是$&#123;num&#125;`;</span><br></pre></td></tr></table></figure>

<p>4.数组类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr1: number[];</span><br><span class="line">arr1 = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let arr2: Array&lt;number&gt;;</span><br><span class="line">arr2 = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let arr3: (string | number)[];</span><br><span class="line">arr3 = [1, &#x27;2&#x27;, 3];</span><br></pre></td></tr></table></figure>

<p>5.元组类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let tuple: [string, number, boolean];</span><br><span class="line">tuple = [&#x27;a&#x27;, 1, false]; // 必须按照上面的顺序和类型</span><br><span class="line">tuple = [&#x27;a&#x27;, false, false]; // Error：不能将类型“boolean”分配给类型“number”。</span><br><span class="line">tuple = [&#x27;a&#x27;, 1, false, 12]; // Error：不能将类型“[string, number, false, number]”分配给类型“[string, number, boolean]”。</span><br></pre></td></tr></table></figure>

<p>6.枚举类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Roles &#123;</span><br><span class="line">  SUPER_ADMIN, // 0</span><br><span class="line">  ADMIN, // 1</span><br><span class="line">  USER // 2</span><br><span class="line">&#125;</span><br><span class="line">console.log(Roles.SUPER_ADMIN); // 0</span><br><span class="line">console.log(Roles[Roles.SUPER_ADMIN]); // SUPER_ADMIN</span><br></pre></td></tr></table></figure>

<p>7.any类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let value: any;</span><br><span class="line">value = &#x27;abc&#x27;</span><br><span class="line">value =2</span><br><span class="line">value = [1,2,3]</span><br><span class="line">let arr: any[] = [1,&#x27;a&#x27;]</span><br></pre></td></tr></table></figure>

<p>8.void类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const consoleText = (text: string): void =&gt; &#123; // 不返回内容</span><br><span class="line">  console.log(text);</span><br><span class="line">&#125;;</span><br><span class="line">let v: void;</span><br><span class="line">v = undefined;</span><br><span class="line">v = null; // tsconfig的strict需要关掉</span><br></pre></td></tr></table></figure>

<p>9.null和undefined</p>
<p>null 和 undefined 是其他类型的子类型</p>
<p>10.never类型</p>
<p>表示永远不存在的类型，抛错or死循环，返回值就是 never 类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const errorFunc = (message: string): never =&gt; &#123;</span><br><span class="line">  throw new Error(message);</span><br><span class="line">&#125;;</span><br><span class="line">const infiniteFunc = (): never =&gt; &#123;</span><br><span class="line">  while(true) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">// let neverVariable: never</span><br><span class="line">let neverVariable = (() =&gt; &#123;</span><br><span class="line">  while(true) &#123;&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>11.对象类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getObject(obj: object): void &#123;</span><br><span class="line">  console.log(obj);</span><br><span class="line">&#125;</span><br><span class="line">getObject(&#123; name: &#x27;dylan&#x27; &#125;);</span><br><span class="line">getObject(123); // Error：类型“number”的参数不能赋给类型“object”的参数。</span><br></pre></td></tr></table></figure>

<p>12.类型断言</p>
<p>值 as 类型</p>
<p>或 &lt;类型&gt;值</p>
<h3 id="二、Symbol"><a href="#二、Symbol" class="headerlink" title="二、Symbol"></a>二、Symbol</h3><p>Symbol值是独一无二的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const s1 = Symbol(); // Symbol()</span><br><span class="line">const s2 = Symbol(); // Symbol()</span><br><span class="line">s1 === s2; // false</span><br></pre></td></tr></table></figure>

<p>目前来说工作上遇到的少</p>
<h3 id="三、接口"><a href="#三、接口" class="headerlink" title="三、接口"></a>三、接口</h3><p>我们可以使用接口来进行限制，使数据更加清晰直观</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface NameInfo &#123;</span><br><span class="line">  firstName?: string;//?代表可选参数，没?不传这个值会报错</span><br><span class="line">  readonly lastName: string; //只读属性，不能更改NameInfo.lastName的值</span><br><span class="line">&#125;</span><br><span class="line">const getFullName = (&#123; firstName, lastName &#125;: NameInfo): string =&gt; &#123;</span><br><span class="line">  return `$&#123;firstName&#125; $&#123;lastName&#125;`;</span><br><span class="line">&#125;;</span><br><span class="line">getFullName(&#123;</span><br><span class="line">  firstName: &#x27;haha&#x27;,</span><br><span class="line">  lastName: &#x27;Lv&#x27;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>多传入参数时使用类型断言或者索引签名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Vegetable &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  type: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getVegetables = (&#123; color, type &#125;: Vegetable) =&gt; &#123;</span><br><span class="line">  return `A $&#123;color ? (color + &#x27; &#x27;) : &#x27;&#x27;&#125;$&#123;type&#125;`;</span><br><span class="line">&#125;;</span><br><span class="line">getVegetables(&#123; type: &#x27;tomato&#x27;, size: 2 &#125;); // Error：类型“&#123; type: string; size: number; &#125;”的参数不能赋给类型“Vegetable”的参数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//类型断言</span><br><span class="line">getVegetables(&#123; type: &#x27;tomato&#x27;, size: 2 &#125; as Vegetable);</span><br><span class="line"></span><br><span class="line">//索引签名</span><br><span class="line">interface Vegetable &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  type: string;</span><br><span class="line">  [prop: string]: any; // 索引签名</span><br><span class="line">&#125;</span><br><span class="line">getVegetables(&#123; type: &#x27;tomato&#x27;, size: 2 &#125;);</span><br></pre></td></tr></table></figure>

<p>定义函数结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 等同于类型别名：type AddFunc = (num1: number, num2: number) =&gt; number;</span><br><span class="line">interface AddFunc &#123;</span><br><span class="line">  (num1: number, num2: number): number</span><br><span class="line">&#125;</span><br><span class="line">const add: AddFunc = (n1, n2) =&gt; n1 + n2;</span><br></pre></td></tr></table></figure>

<p>索引类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface RoleDic &#123;</span><br><span class="line">  [id: number]: string;//id这个索引只能为数值类型</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>接口的继承</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Vegetables &#123;</span><br><span class="line">  color: string;</span><br><span class="line">&#125;</span><br><span class="line">interface Tomato extends Vegetables &#123;</span><br><span class="line">  radius: number;</span><br><span class="line">&#125;</span><br><span class="line">const tomato: Tomato = &#123;</span><br><span class="line">  radius: 1,</span><br><span class="line">  color: &#x27;red&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="四、泛型-T"><a href="#四、泛型-T" class="headerlink" title="四、泛型 T"></a>四、泛型 T</h3><p>为什么要用泛型？ 可以在函数调用时自由化传入的值和返回的值</p>
<p>使用范型约束函数类型：与之前不同的地方在于多了 T 这个泛型参数，可以理解为这个函数：传入了 T（某个类型）作为 value 的类型，返回由 T组成的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//&lt;T&gt; 表示声明一个表示类型的变量，Value: T 表示声明参数是 T 类型的，后面的 : T 表示返回值也是 T 类型的</span><br><span class="line">const getArray = &lt;T&gt;(value: T, times: number = 5): T[] =&gt; &#123;</span><br><span class="line">  return new Array(times).fill(value)</span><br><span class="line">&#125; //如果使用any[]参数也可以任意传，但是也丢失了类型检测的功能</span><br><span class="line"></span><br><span class="line">//第一个T为string，那么value: T也该为string</span><br><span class="line">getArray&lt;string&gt;(&#x27;abc&#x27;).map(item =&gt; item.length); // [3, 3, 3, 3, 3]</span><br></pre></td></tr></table></figure>

<p>使用两个范型变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 参数1是T类型，参数2是U类型，返回类型是元组类型 T,U组成的数组</span><br><span class="line">const getArray = &lt;T, U&gt;(param1: T, param2: U, times: number): [T, U][] =&gt; &#123;</span><br><span class="line">  return new Array(times).fill([param1, param2]);</span><br><span class="line">&#125;;</span><br><span class="line">// 也可以明确泛型调用，不明确的话，TS会自动推导泛型类型：getArray&lt;number, string&gt;(1, &#x27;a&#x27;, 3);</span><br><span class="line">getArray(1, &#x27;a&#x27;, 3); // [[1, &#x27;a&#x27;], [1, &#x27;a&#x27;], [1, &#x27;a&#x27;]]</span><br></pre></td></tr></table></figure>

<br/>

<h3 id="五、交叉类型"><a href="#五、交叉类型" class="headerlink" title="五、交叉类型"></a>五、交叉类型</h3><p>交叉类型就是取多个类型的并集，使用 &amp; 符号定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const mergeFunc = &lt;T, U&gt;(arg1: T, arr2: U): T &amp; U =&gt; &#123;</span><br><span class="line">  let res = &#123;&#125; as T &amp; U; // 使用类型断言来告诉TS这里是（T和U）的交叉类型</span><br><span class="line">  res = Object.assign(arg1, arr2);</span><br><span class="line">  return res;</span><br><span class="line">&#125;;</span><br><span class="line">mergeFunc(&#123; a: &#x27;a&#x27; &#125;, &#123; b: &#x27;b&#x27; &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web前端学习</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello,欢迎来到耀耀切克闹的博客！</title>
    <url>/2022/09/21/hello-world/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>为什么要搭建博客</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
