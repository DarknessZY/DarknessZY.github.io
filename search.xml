<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hello，欢迎来到耀耀切克闹得博客！</title>
    <url>/2022/09/22/hello%EF%BC%8C%E5%8D%9A%E5%AE%A2%EF%BC%81/</url>
    <content><![CDATA[<h1 id="一-为什么要搭建博客？"><a href="#一-为什么要搭建博客？" class="headerlink" title="一.为什么要搭建博客？"></a>一.为什么要搭建博客？</h1><ol>
<li>搭建博客就是为了写博客，整理思路，将学习的知识融会贯通，以教为学。</li>
<li>在这个过程中，你可以认识更多兴趣相投的人。</li>
<li>事件驱动学习，每周持续的博客更新，查看自己是否学习到新东西！</li>
<li>对自己也是一种督促，你拥有一个完全属于自己的博客，会驱动自己分享学习！</li>
</ol>
<h1 id="二-搭建博客方式"><a href="#二-搭建博客方式" class="headerlink" title="二.搭建博客方式"></a>二.搭建博客方式</h1><p><img src="https://cdn.jsdelivr.net/gh/DarknessZY/myblog@master/img/e3d012b007f43c597d5db60b9594379b.png" alt="e3d012b007f43c597d5db60b9594379b"></p>
<h3 id="1-自己开发"><a href="#1-自己开发" class="headerlink" title="1.自己开发"></a>1.自己开发</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    这是最原始的博客建站方式了，自己写代码（前台 + 后台管理+数据库等等）、自己将项目发布上线、自己来维护网站，啥都自己来干。这就意味着全栈的工作，你需要理解和学习的地方有好多好多，在这过程中需要耗费大量时间，但对自己的提升是不可估量的，并且代码掌握在自己手里，很安想加什么功能都不会受到限制，很灵活。这里推荐 Github 上的开源项目，可以在此上进行二次开发：</span><br><span class="line"></span><br><span class="line">Halo博客，一款现代化的开源博客/CMS系统，值得一试。详细部署可以去  https://docs.halo.run</span><br></pre></td></tr></table></figure>

<h3 id="2-站点生成器"><a href="#2-站点生成器" class="headerlink" title="2.站点生成器"></a>2.站点生成器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">博客是一种很典型的网站，所以有大佬将博客的功能（比如文章管理）抽象出来，做成了 站点生成器 ，可以用极少的命令 + 配置文件的方式，自动生成精美的博客网站。本人还是比较菜的，刚毕业，工作了2个月多，前端菜鸡程序员一枚，于是采用了这种方式，也是我极力推荐的一种方式，省时省力，灵活程度虽然比不上完全由自己开发，但适合大多数人的需求。并且，绝大多数的站点生成器都只能生成静态网站，也就是说网站的内容（比如博客文章、文档等）是固定的，不需要从数据库中获取内容，因此有很多优点：</span><br></pre></td></tr></table></figure>

<ul>
<li><p>省钱：把文件扔 GitHub Pages、Gitee Pages 啥的就能免费部署</p>
</li>
<li><p>速度快：省去了数据的动态获取过程，配合 CDN 加载速度飞起</p>
</li>
<li><p>SEO：静态网站更容易被搜索引擎的蜘蛛抓取，稳定排名</p>
</li>
<li><p>易维护：没那么多花里胡哨的功能，比动态网站好维护不少</p>
<p>这里推荐：</p>
<p><img src="https://cdn.jsdelivr.net/gh/DarknessZY/myblog@master/img/e6561ed83d781d08d5298519b34a4752.png" alt="e6561ed83d781d08d5298519b34a4752"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">另外还有一种方式是建站程序，主流就是 WordPress（推荐）或 Typech，跟着官方文档操作就行，不过俺了解甚少。感兴趣的朋友可以去看看，据说也很方便。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-建站平台和购买"><a href="#3-建站平台和购买" class="headerlink" title="3.建站平台和购买"></a>3.建站平台和购买</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单说吧！就是花钱办事，用金钱换时间。</span><br><span class="line"></span><br><span class="line">**建站平台：**套个现成的模板、利用界面拖拖拽拽就能搞出来一个网站，平台还会给你提供域名，一键上线。此外，网站的维护也不用咱自己操心了，全交给别人，我们专注于网站的内容就行</span><br><span class="line"></span><br><span class="line">**购买**: 极致的体验，没有最好，只有更好，你就是大爷，可以尽情享受氪金带来的快乐！（手动狗头)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>为什么要搭建博客</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>TS基础</title>
    <url>/2022/09/22/Typescript/</url>
    <content><![CDATA[<h3 id="一、基础类型"><a href="#一、基础类型" class="headerlink" title="一、基础类型"></a>一、基础类型</h3><p>1.布尔类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let bool: boolean;</span><br><span class="line">bool = false;</span><br><span class="line">bool = 123; // Error：不能将类型“number”分配给类型“boolean”。</span><br></pre></td></tr></table></figure>

<p>2.数值类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num：number = 123</span><br></pre></td></tr></table></figure>

<p>3.字符串类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str: string;</span><br><span class="line">str = &#x27;bac&#x27;;</span><br><span class="line">str = `数值是$&#123;num&#125;`;</span><br></pre></td></tr></table></figure>

<p>4.数组类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr1: number[];</span><br><span class="line">arr1 = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let arr2: Array&lt;number&gt;;</span><br><span class="line">arr2 = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let arr3: (string | number)[];</span><br><span class="line">arr3 = [1, &#x27;2&#x27;, 3];</span><br></pre></td></tr></table></figure>

<p>5.元组类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let tuple: [string, number, boolean];</span><br><span class="line">tuple = [&#x27;a&#x27;, 1, false]; // 必须按照上面的顺序和类型</span><br><span class="line">tuple = [&#x27;a&#x27;, false, false]; // Error：不能将类型“boolean”分配给类型“number”。</span><br><span class="line">tuple = [&#x27;a&#x27;, 1, false, 12]; // Error：不能将类型“[string, number, false, number]”分配给类型“[string, number, boolean]”。</span><br></pre></td></tr></table></figure>

<p>6.枚举类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Roles &#123;</span><br><span class="line">  SUPER_ADMIN, // 0</span><br><span class="line">  ADMIN, // 1</span><br><span class="line">  USER // 2</span><br><span class="line">&#125;</span><br><span class="line">console.log(Roles.SUPER_ADMIN); // 0</span><br><span class="line">console.log(Roles[Roles.SUPER_ADMIN]); // SUPER_ADMIN</span><br></pre></td></tr></table></figure>

<p>7.any类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let value: any;</span><br><span class="line">value = &#x27;abc&#x27;</span><br><span class="line">value =2</span><br><span class="line">value = [1,2,3]</span><br><span class="line">let arr: any[] = [1,&#x27;a&#x27;]</span><br></pre></td></tr></table></figure>

<p>8.void类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const consoleText = (text: string): void =&gt; &#123; // 不返回内容</span><br><span class="line">  console.log(text);</span><br><span class="line">&#125;;</span><br><span class="line">let v: void;</span><br><span class="line">v = undefined;</span><br><span class="line">v = null; // tsconfig的strict需要关掉</span><br></pre></td></tr></table></figure>

<p>9.null和undefined</p>
<p>null 和 undefined 是其他类型的子类型</p>
<p>10.never类型</p>
<p>表示永远不存在的类型，抛错or死循环，返回值就是 never 类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const errorFunc = (message: string): never =&gt; &#123;</span><br><span class="line">  throw new Error(message);</span><br><span class="line">&#125;;</span><br><span class="line">const infiniteFunc = (): never =&gt; &#123;</span><br><span class="line">  while(true) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">// let neverVariable: never</span><br><span class="line">let neverVariable = (() =&gt; &#123;</span><br><span class="line">  while(true) &#123;&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>11.对象类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getObject(obj: object): void &#123;</span><br><span class="line">  console.log(obj);</span><br><span class="line">&#125;</span><br><span class="line">getObject(&#123; name: &#x27;dylan&#x27; &#125;);</span><br><span class="line">getObject(123); // Error：类型“number”的参数不能赋给类型“object”的参数。</span><br></pre></td></tr></table></figure>

<p>12.类型断言</p>
<p>值 as 类型</p>
<p>或 &lt;类型&gt;值</p>
<h3 id="二、Symbol"><a href="#二、Symbol" class="headerlink" title="二、Symbol"></a>二、Symbol</h3><p>Symbol值是独一无二的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const s1 = Symbol(); // Symbol()</span><br><span class="line">const s2 = Symbol(); // Symbol()</span><br><span class="line">s1 === s2; // false</span><br></pre></td></tr></table></figure>

<p>目前来说工作上遇到的少</p>
<h3 id="三、接口"><a href="#三、接口" class="headerlink" title="三、接口"></a>三、接口</h3><p>我们可以使用接口来进行限制，使数据更加清晰直观</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface NameInfo &#123;</span><br><span class="line">  firstName?: string;//?代表可选参数，没?不传这个值会报错</span><br><span class="line">  readonly lastName: string; //只读属性，不能更改NameInfo.lastName的值</span><br><span class="line">&#125;</span><br><span class="line">const getFullName = (&#123; firstName, lastName &#125;: NameInfo): string =&gt; &#123;</span><br><span class="line">  return `$&#123;firstName&#125; $&#123;lastName&#125;`;</span><br><span class="line">&#125;;</span><br><span class="line">getFullName(&#123;</span><br><span class="line">  firstName: &#x27;haha&#x27;,</span><br><span class="line">  lastName: &#x27;Lv&#x27;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>多传入参数时使用类型断言或者索引签名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Vegetable &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  type: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getVegetables = (&#123; color, type &#125;: Vegetable) =&gt; &#123;</span><br><span class="line">  return `A $&#123;color ? (color + &#x27; &#x27;) : &#x27;&#x27;&#125;$&#123;type&#125;`;</span><br><span class="line">&#125;;</span><br><span class="line">getVegetables(&#123; type: &#x27;tomato&#x27;, size: 2 &#125;); // Error：类型“&#123; type: string; size: number; &#125;”的参数不能赋给类型“Vegetable”的参数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//类型断言</span><br><span class="line">getVegetables(&#123; type: &#x27;tomato&#x27;, size: 2 &#125; as Vegetable);</span><br><span class="line"></span><br><span class="line">//索引签名</span><br><span class="line">interface Vegetable &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  type: string;</span><br><span class="line">  [prop: string]: any; // 索引签名</span><br><span class="line">&#125;</span><br><span class="line">getVegetables(&#123; type: &#x27;tomato&#x27;, size: 2 &#125;);</span><br></pre></td></tr></table></figure>

<p>定义函数结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 等同于类型别名：type AddFunc = (num1: number, num2: number) =&gt; number;</span><br><span class="line">interface AddFunc &#123;</span><br><span class="line">  (num1: number, num2: number): number</span><br><span class="line">&#125;</span><br><span class="line">const add: AddFunc = (n1, n2) =&gt; n1 + n2;</span><br></pre></td></tr></table></figure>

<p>索引类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface RoleDic &#123;</span><br><span class="line">  [id: number]: string;//id这个索引只能为数值类型</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>接口的继承</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Vegetables &#123;</span><br><span class="line">  color: string;</span><br><span class="line">&#125;</span><br><span class="line">interface Tomato extends Vegetables &#123;</span><br><span class="line">  radius: number;</span><br><span class="line">&#125;</span><br><span class="line">const tomato: Tomato = &#123;</span><br><span class="line">  radius: 1,</span><br><span class="line">  color: &#x27;red&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="四、泛型-T"><a href="#四、泛型-T" class="headerlink" title="四、泛型 T"></a>四、泛型 T</h3><p>为什么要用泛型？ 可以在函数调用时自由化传入的值和返回的值</p>
<p>使用范型约束函数类型：与之前不同的地方在于多了 T 这个泛型参数，可以理解为这个函数：传入了 T（某个类型）作为 value 的类型，返回由 T组成的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//&lt;T&gt; 表示声明一个表示类型的变量，Value: T 表示声明参数是 T 类型的，后面的 : T 表示返回值也是 T 类型的</span><br><span class="line">const getArray = &lt;T&gt;(value: T, times: number = 5): T[] =&gt; &#123;</span><br><span class="line">  return new Array(times).fill(value)</span><br><span class="line">&#125; //如果使用any[]参数也可以任意传，但是也丢失了类型检测的功能</span><br><span class="line"></span><br><span class="line">//第一个T为string，那么value: T也该为string</span><br><span class="line">getArray&lt;string&gt;(&#x27;abc&#x27;).map(item =&gt; item.length); // [3, 3, 3, 3, 3]</span><br></pre></td></tr></table></figure>

<p>使用两个范型变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 参数1是T类型，参数2是U类型，返回类型是元组类型 T,U组成的数组</span><br><span class="line">const getArray = &lt;T, U&gt;(param1: T, param2: U, times: number): [T, U][] =&gt; &#123;</span><br><span class="line">  return new Array(times).fill([param1, param2]);</span><br><span class="line">&#125;;</span><br><span class="line">// 也可以明确泛型调用，不明确的话，TS会自动推导泛型类型：getArray&lt;number, string&gt;(1, &#x27;a&#x27;, 3);</span><br><span class="line">getArray(1, &#x27;a&#x27;, 3); // [[1, &#x27;a&#x27;], [1, &#x27;a&#x27;], [1, &#x27;a&#x27;]]</span><br></pre></td></tr></table></figure>

<br/>

<h3 id="五、交叉类型"><a href="#五、交叉类型" class="headerlink" title="五、交叉类型"></a>五、交叉类型</h3><p>交叉类型就是取多个类型的并集，使用 &amp; 符号定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const mergeFunc = &lt;T, U&gt;(arg1: T, arr2: U): T &amp; U =&gt; &#123;</span><br><span class="line">  let res = &#123;&#125; as T &amp; U; // 使用类型断言来告诉TS这里是（T和U）的交叉类型</span><br><span class="line">  res = Object.assign(arg1, arr2);</span><br><span class="line">  return res;</span><br><span class="line">&#125;;</span><br><span class="line">mergeFunc(&#123; a: &#x27;a&#x27; &#125;, &#123; b: &#x27;b&#x27; &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web前端学习</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>js</tag>
      </tags>
  </entry>
</search>
